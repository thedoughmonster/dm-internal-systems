#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "${SCRIPT_DIR}/../../../.." && pwd)"
NS_STATE_DIR="${HOME}/.codex/dc/namespaces"

if [[ -t 1 && -z "${NO_COLOR:-}" ]]; then
  C_RESET=$'\033[0m'
  C_CYAN=$'\033[36m'
  C_GREEN=$'\033[32m'
  C_YELLOW=$'\033[33m'
  C_RED=$'\033[31m'
  C_MAGENTA=$'\033[35m'
  C_DIM=$'\033[2m'
else
  C_RESET=""
  C_CYAN=""
  C_GREEN=""
  C_YELLOW=""
  C_RED=""
  C_MAGENTA=""
  C_DIM=""
fi

color() {
  local c="$1"
  shift
  printf "%s%s%s" "${c}" "$*" "${C_RESET}"
}

print_row() {
  local indent="$1"
  local label_raw="$2"
  local desc="$3"
  local row_color="$4"
  local width=32
  local pad=$(( width - ${#label_raw} ))
  if (( pad < 1 )); then
    pad=1
  fi
  local line
  line="$(printf "%s%s%*s%s" "${indent}" "${label_raw}" "${pad}" "" "${desc}")"
  printf "%s\n" "$(color "${row_color}" "${line}")"
}

normalize_namespace() {
  local raw="${1:-}"
  raw="$(printf "%s" "$raw" | tr '[:upper:]' '[:lower:]' | xargs)"
  case "$raw" in
    agent|agents|machine|ma) echo "agent" ;;
    op|operator) echo "op" ;;
    ""|all|auto) echo "all" ;;
    *) echo "" ;;
  esac
}

tty_key() {
  if [[ ! -t 0 ]]; then
    echo ""
    return 0
  fi
  local t
  t="$(tty 2>/dev/null || true)"
  if [[ -z "$t" || "$t" == "not a tty" ]]; then
    echo ""
    return 0
  fi
  t="${t#/dev/}"
  t="${t//\//_}"
  printf "%s" "$t"
}

ns_state_file() {
  local key
  key="$(tty_key)"
  if [[ -z "$key" ]]; then
    echo ""
    return 0
  fi
  mkdir -p "${NS_STATE_DIR}"
  printf "%s/%s.env" "${NS_STATE_DIR}" "$key"
}

read_pinned_namespace() {
  local f
  f="$(ns_state_file)"
  if [[ -z "$f" || ! -f "$f" ]]; then
    echo ""
    return 0
  fi
  local v
  v="$(sed -n 's/^namespace=//p' "$f" | head -n1)"
  normalize_namespace "$v"
}

read_pinned_role() {
  local f
  f="$(ns_state_file)"
  if [[ -z "$f" || ! -f "$f" ]]; then
    echo ""
    return 0
  fi
  sed -n 's/^role=//p' "$f" | head -n1
}

write_pinned_namespace() {
  local ns="$1"
  local role="${2:-}"
  local f
  f="$(ns_state_file)"
  if [[ -z "$f" ]]; then
    return 0
  fi
  {
    printf "namespace=%s\n" "$ns"
    printf "role=%s\n" "$role"
  } > "$f"
}

clear_pinned_namespace() {
  local f
  f="$(ns_state_file)"
  if [[ -n "$f" && -f "$f" ]]; then
    rm -f "$f"
  fi
}

effective_namespace() {
  local env_ns
  env_ns="$(normalize_namespace "${DC_NAMESPACE:-}")"
  if [[ -n "$env_ns" && "$env_ns" != "all" ]]; then
    printf "%s" "$env_ns"
    return 0
  fi
  local pinned
  pinned="$(read_pinned_namespace)"
  if [[ -n "$pinned" && "$pinned" != "all" ]]; then
    printf "%s" "$pinned"
    return 0
  fi
  echo ""
}

effective_role() {
  if [[ -n "${DC_ROLE:-}" ]]; then
    printf "%s" "${DC_ROLE}"
    return 0
  fi
  read_pinned_role
}

effective_namespace_source() {
  local env_ns
  env_ns="$(normalize_namespace "${DC_NAMESPACE:-}")"
  if [[ -n "$env_ns" && "$env_ns" != "all" ]]; then
    printf "env"
    return 0
  fi
  local pinned
  pinned="$(read_pinned_namespace)"
  if [[ -n "$pinned" && "$pinned" != "all" ]]; then
    printf "pinned"
    return 0
  fi
  printf "unset"
}

is_audience_visible() {
  local mode="$1"
  local audience="$2"
  case "$mode" in
    all)
      return 0
      ;;
    op)
      [[ "$audience" == "op" || "$audience" == "both" ]]
      return
      ;;
    agents)
      [[ "$audience" == "agent" || "$audience" == "both" ]]
      return
      ;;
    *)
      return 0
      ;;
  esac
}

audience_tag() {
  local audience="$1"
  case "$audience" in
    op) printf "%s" "$(color "${C_YELLOW}" "[op]")" ;;
    agent) printf "%s" "$(color "${C_MAGENTA}" "[agent]")" ;;
    both) printf "%s" "$(color "${C_GREEN}" "[both]")" ;;
    *) printf "%s" "[?]" ;;
  esac
}

print_command() {
  local mode="$1"
  local cmd="$2"
  local audience="$3"
  local desc="$4"
  if ! is_audience_visible "$mode" "$audience"; then
    return 0
  fi
  print_row "  " "${cmd}" "$(audience_tag "$audience") ${desc}" "${C_GREEN}"
}

log_cmd_line() {
  local ts cmdline
  ts="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  cmdline=""
  for part in "$@"; do
    if [[ -n "$cmdline" ]]; then cmdline+=" "; fi
    cmdline+="$(printf '%q' "$part")"
  done
  printf "[%s] [CMD] %s\n" "$ts" "$cmdline"
}

run_logged() {
  local log_file="${DC_SESSION_LOG:-}"
  if [[ -n "$log_file" ]]; then
    mkdir -p "$(dirname "$log_file")"
    log_cmd_line "$@" >> "$log_file"
    "$@" > >(tee -a "$log_file") 2> >(tee -a "$log_file" >&2)
    local rc=$?
    printf "[%s] [CMD_EXIT] %s\n" "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" "$rc" >> "$log_file"
    return "$rc"
  fi
  "$@"
}

usage() {
  local mode="${1:-all}"
  local shown_mode="$mode"
  if [[ "$mode" == "current" ]]; then
    local current
    current="$(effective_namespace)"
    if [[ -z "$current" || "$current" == "all" ]]; then
      shown_mode="all"
    elif [[ "$current" == "agent" ]]; then
      shown_mode="agents"
    else
      shown_mode="op"
    fi
  fi

  printf "%s\n" "Usage:"
  printf "  %s\n" "$(color "${C_GREEN}" "dc <category> <command> [args...]")"
  printf "  %s\n" "$(color "${C_GREEN}" "dc help [--all|--op|--agents]")"
  printf "\n%s\n" "$(color "${C_CYAN}" "Namespace")"
  local ns_now
  ns_now="$(effective_namespace)"
  local role_now
  role_now="$(effective_role)"
  local ns_src
  ns_src="$(effective_namespace_source)"
  print_row "  " "current" "$(color "${C_DIM}" "${ns_now:-unset} (${ns_src})")" "${C_YELLOW}"
  print_row "  " "role" "$(color "${C_DIM}" "${role_now:-unset}")" "${C_YELLOW}"
  printf "\n%s\n" "$(color "${C_CYAN}" "Commands (single list)")"

  print_command "$shown_mode" "init" "op" "Initialize companion config (agent/model defaults)"
  print_command "$shown_mode" "codex usage" "both" "Report codex token usage from ~/.codex logs"
  print_command "$shown_mode" "repo map" "both" "Show high-signal repo paths and execution zones"
  print_command "$shown_mode" "policy validate" "agent" "Validate required policy JSON files"
  print_command "$shown_mode" "runbook <name>" "agent" "Run scripted multi-step lifecycle checkpoints"

  print_command "$shown_mode" "context build" "op" "Build compiled context bundle"
  print_command "$shown_mode" "context check" "both" "Check whether context bundle is up to date"
  print_command "$shown_mode" "context show" "both" "Show machine-readable context/profile metadata"
  print_command "$shown_mode" "context bootstrap" "op" "Update ~/.codex/config.toml profile wiring"
  print_command "$shown_mode" "launch codex" "op" "Prompt/select profile+role+directive, then launch codex"
  print_command "$shown_mode" "launch switch" "op" "Switch to a new codex profile/role session"
  print_command "$shown_mode" "launch handoff" "both" "Create handoff artifact, then switch codex role/session"

  print_command "$shown_mode" "directive new" "op" "Create <directive_slug>.meta.json"
  print_command "$shown_mode" "directive task" "agent" "Create <task_slug>.task.json"
  print_command "$shown_mode" "directive handoff" "agent" "Create <directive_slug>.handoff.json"
  print_command "$shown_mode" "directive list" "both" "List directives with selectable output detail"
  print_command "$shown_mode" "directive view" "both" "Human-readable directive/task/handoff viewer"
  print_command "$shown_mode" "directive start" "agent" "Executor directive startup flow (auto-pins terminal)"
  print_command "$shown_mode" "directive finish" "agent" "Executor directive closeout metadata + validation"
  print_command "$shown_mode" "directive archive" "both" "Archive directive metadata (git is manual)"
  print_command "$shown_mode" "directive merge" "both" "Mark merge_status after operator merges branch"
  print_command "$shown_mode" "directive cleanup" "agent" "Show manual merged-branch cleanup guidance"
  print_command "$shown_mode" "directive migrate" "both" "Migrate legacy directive files to JSON format"

  print_command "$shown_mode" "task start" "agent" "Start task with guards"
  print_command "$shown_mode" "task finish" "agent" "Finish task with validation + metadata updates"

  print_command "$shown_mode" "meta update" "agent" "Update metadata"
  print_command "$shown_mode" "meta architect" "agent" "Architect-guarded metadata updates"
  print_command "$shown_mode" "meta executor" "agent" "Executor-guarded metadata updates"

  print_command "$shown_mode" "validate" "both" "Run directives validator"
  print_command "$shown_mode" "test" "both" "Run directive tooling test suite"

  print_command "$shown_mode" "ns show" "both" "Show active namespace+role"
  print_command "$shown_mode" "ns env <op|agent>" "both" "Print export lines for eval"
  print_command "$shown_mode" "ns enter <op|agent>" "both" "Start subshell pinned to namespace"
  print_command "$shown_mode" "ns clear" "both" "Clear terminal pin for current TTY"

  printf "\n%s\n" "$(color "${C_CYAN}" "Help filters")"
  print_row "  " "--all" "Show complete command list" "${C_GREEN}"
  print_row "  " "--op" "Show operator-visible commands" "${C_GREEN}"
  print_row "  " "--agents" "Show agent-visible commands" "${C_GREEN}"
  printf "\n%s\n" "$(color "${C_CYAN}" "Reference")"
  print_row "  " "full docs" ".directive-cli/docs/CLI_REFERENCE.md" "${C_GREEN}"
}

category_usage() {
  local category="$1"
  printf "%s\n" "Usage:"
  case "$category" in
    directive)
      printf "  %s\n" "$(color "${C_GREEN}" "dc directive <new|task|handoff|list|view|start|finish|archive|merge|cleanup|migrate> [args...]")"
      printf "\nExamples:\n"
      printf "  dc directive list --detailed\n"
      printf "  dc directive view --directive <session> --file <name>.json\n"
      printf "  dc directive start --session <session>\n"
      printf "  dc directive merge --session <session>  # metadata mark only (no merge execution)\n"
      ;;
    task)
      printf "  %s\n" "$(color "${C_GREEN}" "dc task <start|finish> [args...]")"
      printf "\nExamples:\n"
      printf "  dc task start --session <session> --task <task-slug>\n"
      printf "  dc task finish --session <session> --task <task-slug> --summary \"...\"\n"
      ;;
    meta)
      printf "  %s\n" "$(color "${C_GREEN}" "dc meta <update|architect|executor> [args...]")"
      printf "\nExamples:\n"
      printf "  dc meta architect --session <session> --directive-meta --set status=ready\n"
      printf "  dc meta executor --session <session> --task <task-slug> --set status=done\n"
      ;;
    launch)
      printf "  %s\n" "$(color "${C_GREEN}" "dc launch <codex|switch|handoff> [args...]")"
      printf "\nExamples:\n"
      printf "  dc launch codex\n"
      printf "  dc launch handoff --directive <session> --task <task-slug>\n"
      ;;
    context)
      printf "  %s\n" "$(color "${C_GREEN}" "dc context <build|check|show|bootstrap|start|switch|handoff> [args...]")"
      ;;
    runbook)
      printf "  %s\n" "$(color "${C_GREEN}" "dc runbook <executor-task-cycle|executor-directive-closeout|executor-directive-cleanup|architect-authoring> [args...]")"
      printf "\nExamples:\n"
      printf "  dc runbook executor-task-cycle --session <session> --task <task> --phase pre --confirm executor-task-cycle-pre\n"
      printf "  dc runbook executor-directive-closeout --session <session> --confirm executor-directive-closeout\n"
      printf "  dc runbook executor-directive-closeout --session <session> --confirm executor-directive-closeout --qa-status pass\n"
      printf "  # Note: runbook closeout prints manual git checklist; dc does not execute git merge/cleanup.\n"
      ;;
    repo)
      printf "  %s\n" "$(color "${C_GREEN}" "dc repo map")"
      ;;
    codex)
      printf "  %s\n" "$(color "${C_GREEN}" "dc codex <usage> [args...]")"
      printf "\nExamples:\n"
      printf "  dc codex usage --hours 24\n"
      printf "  dc codex usage --since 2026-02-14T00:00:00Z --until 2026-02-15T00:00:00Z --json\n"
      ;;
    policy)
      printf "  %s\n" "$(color "${C_GREEN}" "dc policy validate")"
      ;;
    *)
      printf "  %s\n" "$(color "${C_GREEN}" "dc help")"
      ;;
  esac
  printf "\n%s\n" "$(color "${C_CYAN}" "Reference: .directive-cli/docs/CLI_REFERENCE.md")"
}

is_agent_namespace() {
  [[ "$(effective_namespace)" == "agent" ]]
}

current_phase() {
  printf "%s" "${DC_RUNBOOK_PHASE:-}" | tr '[:upper:]' '[:lower:]' | xargs
}

phase_command_key() {
  local cmd="$1"
  local sub="$2"
  if [[ -z "$sub" ]]; then
    printf "%s" "$cmd"
    return 0
  fi
  printf "%s %s" "$cmd" "$sub"
}

phase_allowed_commands() {
  local phase="$1"
  case "$phase" in
    architect-discovery)
      printf "%s\n" \
        "help" "repo map" "context show" "context check" \
        "directive list" "directive view" "directive new" \
        "validate" "policy validate" "runbook"
      ;;
    architect-authoring)
      printf "%s\n" \
        "help" "repo map" "context show" "context check" \
        "directive list" "directive view" "directive task" "directive handoff" \
        "meta architect" "meta update" "validate" "policy validate" "runbook"
      ;;
    executor-start)
      printf "%s\n" \
        "help" "context show" "context check" \
        "directive list" "directive view" "directive start" "task start" \
        "validate" "runbook"
      ;;
    executor-task)
      printf "%s\n" \
        "help" "context show" "context check" \
        "directive list" "directive view" "directive start" "task start" "task finish" \
        "validate" "runbook"
      ;;
    executor-closeout)
      printf "%s\n" \
        "help" "context show" "context check" \
        "directive list" "directive view" "runbook" \
        "directive finish" "directive merge" "directive archive" "directive cleanup" \
        "validate"
      ;;
    *)
      ;;
  esac
}

resolve_directive_branch_for_session() {
  local session="$1"
  if [[ -z "$session" ]]; then
    return 0
  fi
  node -e '
    const fs=require("fs");
    const path=require("path");
    const root=process.argv[1];
    const session=process.argv[2];
    const dir=path.join(root,".directive-cli","directives",session);
    if(!fs.existsSync(dir)){process.exit(0);}
    const files=fs.readdirSync(dir).filter((f)=>f.endsWith(".meta.json")).sort();
    if(files.length===0){process.exit(0);}
    const doc=JSON.parse(fs.readFileSync(path.join(dir,files[0]),"utf8"));
    const meta=doc&&doc.meta&&typeof doc.meta==="object"?doc.meta:{};
    const branch=String(meta.directive_branch||"").trim();
    process.stdout.write(branch);
  ' "${ROOT_DIR}" "$session"
}

enforce_architect_authoring_branch_scope() {
  if ! is_agent_namespace; then
    return 0
  fi
  local phase role_now
  phase="$(current_phase)"
  role_now="$(effective_role)"
  [[ "$phase" == "architect-authoring" && "$role_now" == "architect" ]] || return 0

  local session current branch_required
  session="${DC_DIRECTIVE_SESSION:-}"
  current="$(git -C "${ROOT_DIR}" rev-parse --abbrev-ref HEAD 2>/dev/null || true)"
  branch_required="$(resolve_directive_branch_for_session "$session")"
  if [[ -z "$session" || -z "$branch_required" ]]; then
    return 0
  fi
  if [[ "$current" == "$branch_required" ]]; then
    return 0
  fi

  printf "%s\n" "$(color "${C_RED}" "Blocked by architect authoring branch guard.")" >&2
  printf "%s\n" "Current branch '${current:-unknown}' does not match directive branch '${branch_required}' for session '${session}'." >&2
  printf "%s\n" "Switch to the directive branch before running authoring commands." >&2
  exit 1
}

enforce_phase_scope() {
  local cmd="$1"
  local sub="$2"
  if ! is_agent_namespace; then
    return 0
  fi
  local phase
  phase="$(current_phase)"
  if [[ -z "$phase" ]]; then
    return 0
  fi

  local key
  key="$(phase_command_key "$cmd" "$sub")"
  local matched=0
  local allowed
  while IFS= read -r allowed; do
    [[ -z "$allowed" ]] && continue
    if [[ "$allowed" == "$key" || ( "$allowed" == "help" && "$cmd" == "help" ) ]]; then
      matched=1
      break
    fi
  done < <(phase_allowed_commands "$phase")

  if [[ "$matched" -eq 1 ]]; then
    return 0
  fi

  printf "%s\n" "$(color "${C_RED}" "Blocked by runbook phase guard: '${cmd}${sub:+ ${sub}}' is not allowed in phase '${phase}'.")" >&2
  printf "%s\n" "$(color "${C_YELLOW}" "Allowed commands in this phase:")" >&2
  while IFS= read -r allowed; do
    [[ -z "$allowed" ]] && continue
    printf "  - %s\n" "$allowed" >&2
  done < <(phase_allowed_commands "$phase")
  printf "%s\n" "Use 'dc runbook' to continue with phase-scoped flow." >&2
  exit 1
}

collect_dirty_files() {
  local -a entries=()
  while IFS= read -r -d '' entry; do
    entries+=("$entry")
  done < <(git -C "${ROOT_DIR}" status --porcelain=1 -z 2>/dev/null || true)

  local -a paths=()
  local item code payload p1 p2
  for item in "${entries[@]}"; do
    code="${item:0:2}"
    payload="${item:3}"
    case "$code" in
      R*|C*)
        p1="${payload%% -> *}"
        p2="${payload##* -> }"
        [[ -n "$p1" ]] && paths+=("$p1")
        [[ -n "$p2" ]] && paths+=("$p2")
        ;;
      *)
        [[ -n "$payload" ]] && paths+=("$payload")
        ;;
    esac
  done

  if (( ${#paths[@]} == 0 )); then
    return 0
  fi

  printf "%s\n" "${paths[@]}" | awk 'NF{print}' | sort -u
}

is_architect_write_command() {
  local cmd="$1"
  local sub="$2"
  case "$cmd:$sub" in
    directive:task|directive:handoff|meta:architect|meta:update|runbook:architect-authoring)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

architect_write_scope_guard() {
  local cmd="$1"
  local sub="$2"
  local role_now
  role_now="$(effective_role)"
  [[ "$role_now" == "architect" ]] || return 0
  is_architect_write_command "$cmd" "$sub" || return 0

  local -a allowed_prefixes=(
    ".directive-cli/"
    ".codex/context/"
    "directive-cli/"
    "codex/context/"
  )
  local -a disallowed=()
  local path_value allowed prefix
  while IFS= read -r path_value; do
    [[ -z "$path_value" ]] && continue
    allowed=0
    for prefix in "${allowed_prefixes[@]}"; do
      if [[ "$path_value" == "$prefix"* ]]; then
        allowed=1
        break
      fi
    done
    if [[ "$allowed" -eq 0 ]]; then
      disallowed+=("$path_value")
    fi
  done < <(collect_dirty_files)

  if (( ${#disallowed[@]} == 0 )); then
    return 0
  fi

  printf "%s\n" "$(color "${C_RED}" "+====================================================================+")" >&2
  printf "%s\n" "$(color "${C_RED}" "|  BLOCKED: Architect Write Scope Guard                             |")" >&2
  printf "%s\n" "$(color "${C_RED}" "+--------------------------------------------------------------------+")" >&2
  printf "%s\n" "$(color "${C_RED}" "| Architect authoring may only proceed when dirty files are limited  |")" >&2
  printf "%s\n" "$(color "${C_RED}" "| to .directive-cli/ (plus generated .codex/context artifacts).      |")" >&2
  printf "%s\n" "$(color "${C_RED}" "+====================================================================+")" >&2
  printf "%s\n" "$(color "${C_YELLOW}" "Disallowed dirty files:")" >&2
  local shown=0
  for path_value in "${disallowed[@]}"; do
    printf "  - %s\n" "$path_value" >&2
    shown=$((shown + 1))
    if (( shown >= 20 )); then
      local remaining=$(( ${#disallowed[@]} - shown ))
      if (( remaining > 0 )); then
        printf "  ... (%d more)\n" "$remaining" >&2
      fi
      break
    fi
  done
  printf "%s\n" "Resolve or stash non-directive changes before architect authoring commands." >&2
  exit 1
}

auto_pin_agent_namespace() {
  local role="${1:-executor}"
  if ! role_is_valid "$role"; then
    role="executor"
  fi
  export DC_NAMESPACE="agent"
  export DC_ROLE="${role}"
  write_pinned_namespace "agent" "${role}"
  if [[ -t 1 ]]; then
    printf "%s\n" "$(color "${C_CYAN}" "Pinned terminal namespace: agent (${role})")" >&2
  fi
}

is_operator_only_command() {
  local cmd="$1"
  local sub="$2"
  case "$cmd:$sub" in
    init:)
      return 0
      ;;
    context:build|context:bootstrap)
      return 0
      ;;
    launch:codex)
      return 0
      ;;
    launch:switch)
      return 0
      ;;
    directive:new)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

is_phase_override_for_operator_only() {
  local cmd="$1"
  local sub="$2"
  local phase role_now
  phase="$(current_phase)"
  role_now="$(effective_role)"
  if [[ "$cmd:$sub" == "directive:new" && "$phase" == "architect-discovery" && "$role_now" == "architect" ]]; then
    return 0
  fi
  return 1
}

is_architect_authoring_lock_active() {
  [[ "${DC_ROLE:-}" == "architect" && -n "${DC_DIRECTIVE_SESSION:-}" && -z "${DC_TASK_SLUG:-}" ]]
}

is_allowed_under_architect_authoring_lock() {
  local cmd="$1"
  local sub="$2"
  case "$cmd:$sub" in
    help:|-h:|--help:)
      return 0
      ;;
    ns:|namespace:)
      return 0
      ;;
    repo:map)
      return 0
      ;;
    context:show|context:check)
      return 0
      ;;
    policy:validate)
      return 0
      ;;
    validate:|test:)
      return 0
      ;;
    directive:list|directive:view|directive:task|directive:handoff)
      return 0
      ;;
    meta:architect|meta:update)
      return 0
      ;;
    runbook:architect-authoring)
      return 0
      ;;
    launch:handoff)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

enforce_architect_authoring_lock() {
  local cmd="$1"
  local sub="$2"
  if ! is_architect_authoring_lock_active; then
    return 0
  fi
  if is_allowed_under_architect_authoring_lock "$cmd" "$sub"; then
    return 0
  fi

  printf "%s\n" "$(color "${C_RED}" "Blocked by architect authoring lock: '${cmd}${sub:+ ${sub}}' is not allowed before task approval + handoff.")" >&2
  printf "%s\n" "$(color "${C_YELLOW}" "Active directive: ${DC_DIRECTIVE_SESSION}")" >&2
  printf "%s\n" "Allowed now: directive list/view/task/handoff, meta architect, validate, context show/check, runbook architect-authoring." >&2
  printf "%s\n" "Next steps: approve task plan -> create tasks -> approve contracts -> create handoff to executor." >&2
  exit 1
}

enforce_namespace_policy() {
  local cmd="$1"
  local sub="$2"
  enforce_architect_authoring_lock "$cmd" "$sub"
  architect_write_scope_guard "$cmd" "$sub"
  enforce_phase_scope "$cmd" "$sub"
  enforce_architect_authoring_branch_scope
  if ! is_agent_namespace; then
    return 0
  fi
  if is_phase_override_for_operator_only "$cmd" "$sub"; then
    return 0
  fi
  if is_operator_only_command "$cmd" "$sub"; then
    printf "%s\n" "$(color "${C_RED}" "Blocked by namespace policy: '${cmd}${sub:+ ${sub}}' is operator-only.")" >&2
    printf "%s\n" "$(color "${C_YELLOW}" "Current namespace: agent (source=$(effective_namespace_source))")" >&2
    printf "%s\n" "Use 'dc help --agents' for allowed commands, or switch namespace with: eval \"\$(dc ns env op)\"" >&2
    exit 1
  fi
}

ns_usage() {
  cat <<'USAGE'
Usage:
  dc ns show
  dc ns env <op|agent> [--role <architect|executor|pair|auditor>]
  dc ns enter <op|agent> [--role <architect|executor|pair|auditor>]
  dc ns clear
USAGE
}

role_is_valid() {
  case "${1:-}" in
    architect|executor|pair|auditor) return 0 ;;
    *) return 1 ;;
  esac
}

ns_cmd() {
  local sub="${1:-}"
  if [[ $# -gt 0 ]]; then shift; fi

  case "$sub" in
    show)
      local ns_now
      ns_now="$(effective_namespace)"
      local role_now
      role_now="$(effective_role)"
      printf "namespace=%s\n" "${ns_now:-unset}"
      printf "role=%s\n" "${role_now:-unset}"
      printf "source=%s\n" "$(effective_namespace_source)"
      ;;
    env)
      local ns_raw="${1:-}"
      if [[ $# -gt 0 ]]; then shift; fi
      local ns
      ns="$(normalize_namespace "$ns_raw")"
      if [[ -z "$ns" || "$ns" == "all" ]]; then
        echo "Invalid namespace '$ns_raw' (expected: op|agent)" >&2
        exit 1
      fi
      local role=""
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --role)
            shift
            role="${1:-}"
            ;;
          *)
            echo "Unknown ns env arg: $1" >&2
            exit 1
            ;;
        esac
        shift || true
      done
      if [[ "$ns" == "agent" ]]; then
        if [[ -n "$role" ]] && ! role_is_valid "$role"; then
          echo "Invalid --role '$role' (architect|executor|pair|auditor)" >&2
          exit 1
        fi
        if [[ -z "$role" ]]; then role="executor"; fi
        printf "export DC_NAMESPACE=agent\n"
        printf "export DC_ROLE=%q\n" "$role"
      else
        printf "export DC_NAMESPACE=op\n"
        printf "unset DC_ROLE\n"
      fi
      ;;
    enter)
      local ns_raw="${1:-}"
      if [[ $# -gt 0 ]]; then shift; fi
      local ns
      ns="$(normalize_namespace "$ns_raw")"
      if [[ -z "$ns" || "$ns" == "all" ]]; then
        echo "Invalid namespace '$ns_raw' (expected: op|agent)" >&2
        exit 1
      fi
      local role=""
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --role)
            shift
            role="${1:-}"
            ;;
          *)
            echo "Unknown ns enter arg: $1" >&2
            exit 1
            ;;
        esac
        shift || true
      done
      local shell_bin="${SHELL:-bash}"
      if [[ "$ns" == "agent" ]]; then
        if [[ -n "$role" ]] && ! role_is_valid "$role"; then
          echo "Invalid --role '$role' (architect|executor|pair|auditor)" >&2
          exit 1
        fi
        if [[ -z "$role" ]]; then role="executor"; fi
        echo "Entering agent namespace shell (role=$role). Exit shell to return." >&2
        exec env DC_NAMESPACE=agent DC_ROLE="$role" "$shell_bin" -i
      fi
      echo "Entering operator namespace shell. Exit shell to return." >&2
      exec env DC_NAMESPACE=op "$shell_bin" -i
      ;;
    clear)
      clear_pinned_namespace
      if [[ -t 1 ]]; then
        echo "Cleared terminal namespace pin for current TTY." >&2
      fi
      ;;
    help|-h|--help|"")
      ns_usage
      ;;
    *)
      echo "Unknown ns command: $sub" >&2
      ns_usage >&2
      exit 1
      ;;
  esac
}

cmd="${1:-help}"
if [[ $# -gt 0 ]]; then
  shift
fi

if [[ "$cmd" == "help" || "$cmd" == "-h" || "$cmd" == "--help" ]]; then
  mode="current"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --all) mode="all" ;;
      --op) mode="op" ;;
      --agents) mode="agents" ;;
      *)
        echo "Unknown help arg: $1" >&2
        exit 1
        ;;
    esac
    shift
  done
  usage "$mode"
  exit 0
fi

case "$cmd" in
  init)
    enforce_namespace_policy "init" ""
    run_logged "${SCRIPT_DIR}/init" "$@"
    exit $?
    ;;
  repo)
    sub="${1:-}"
    if [[ $# -gt 0 ]]; then shift; fi
    if [[ -z "$sub" || "$sub" == "help" || "$sub" == "--help" || "$sub" == "-h" ]]; then
      category_usage "repo"
      exit 0
    fi
    enforce_namespace_policy "repo" "$sub"
    case "$sub" in
      map)
        run_logged "${SCRIPT_DIR}/repomap" "$@"
        exit $?
        ;;
      *)
        echo "Unknown repo command: ${sub:-<none>}" >&2
        usage >&2
        exit 1
        ;;
    esac
    ;;
  codex)
    sub="${1:-}"
    if [[ $# -gt 0 ]]; then shift; fi
    if [[ -z "$sub" || "$sub" == "help" || "$sub" == "--help" || "$sub" == "-h" ]]; then
      category_usage "codex"
      exit 0
    fi
    enforce_namespace_policy "codex" "$sub"
    case "$sub" in
      usage)
        run_logged "${SCRIPT_DIR}/codexusage" "$@"
        exit $?
        ;;
      *)
        echo "Unknown codex command: ${sub:-<none>}" >&2
        usage >&2
        exit 1
        ;;
    esac
    ;;
  policy)
    sub="${1:-}"
    if [[ $# -gt 0 ]]; then shift; fi
    if [[ -z "$sub" || "$sub" == "help" || "$sub" == "--help" || "$sub" == "-h" ]]; then
      category_usage "policy"
      exit 0
    fi
    enforce_namespace_policy "policy" "$sub"
    case "$sub" in
      validate)
        run_logged "${SCRIPT_DIR}/validatepolicies" "$@"
        exit $?
        ;;
      *)
        echo "Unknown policy command: ${sub:-<none>}" >&2
        usage >&2
        exit 1
        ;;
    esac
    ;;
  runbook)
    if [[ "${1:-}" == "help" || "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
      category_usage "runbook"
      exit 0
    fi
    enforce_namespace_policy "runbook" ""
    run_logged "${SCRIPT_DIR}/runbook" "$@"
    exit $?
    ;;
  context)
    sub="${1:-}"
    if [[ $# -gt 0 ]]; then shift; fi
    if [[ -z "$sub" || "$sub" == "help" || "$sub" == "--help" || "$sub" == "-h" ]]; then
      category_usage "context"
      exit 0
    fi
    enforce_namespace_policy "context" "$sub"
    run_logged "${SCRIPT_DIR}/context" "$sub" "$@"
    exit $?
    ;;
  launch)
    sub="${1:-}"
    if [[ $# -gt 0 ]]; then shift; fi
    if [[ -z "$sub" || "$sub" == "help" || "$sub" == "--help" || "$sub" == "-h" ]]; then
      category_usage "launch"
      exit 0
    fi
    enforce_namespace_policy "launch" "$sub"
    case "$sub" in
      codex)
        run_logged "${SCRIPT_DIR}/context" start "$@"
        exit $?
        ;;
      switch)
        run_logged "${SCRIPT_DIR}/context" switch "$@"
        exit $?
        ;;
      handoff)
        run_logged "${SCRIPT_DIR}/context" handoff "$@"
        exit $?
        ;;
      *)
        echo "Unknown launch command: ${sub:-<none>}" >&2
        usage >&2
        exit 1
        ;;
    esac
    ;;
  agent)
    # compatibility alias
    sub="${1:-}"
    if [[ $# -gt 0 ]]; then shift; fi
    enforce_namespace_policy "context" "$sub"
    run_logged "${SCRIPT_DIR}/context" "$sub" "$@"
    exit $?
    ;;
  directive)
    sub="${1:-}"
    if [[ $# -gt 0 ]]; then shift; fi
    if [[ -z "$sub" || "$sub" == "help" || "$sub" == "--help" || "$sub" == "-h" ]]; then
      category_usage "directive"
      exit 0
    fi
    enforce_namespace_policy "directive" "$sub"
    case "$sub" in
      new)
        run_logged "${SCRIPT_DIR}/newdirective" "$@"
        exit $?
        ;;
      task)
        run_logged "${SCRIPT_DIR}/newtask" "$@"
        exit $?
        ;;
      handoff)
        run_logged "${SCRIPT_DIR}/newhandoff" "$@"
        exit $?
        ;;
      list)
        run_logged "${SCRIPT_DIR}/listdirectives" "$@"
        exit $?
        ;;
      view)
        run_logged "${SCRIPT_DIR}/viewdirective" "$@"
        exit $?
        ;;
      start)
        auto_pin_agent_namespace "${DC_ROLE:-executor}"
        run_logged "${SCRIPT_DIR}/directivestart" "$@"
        exit $?
        ;;
      finish)
        run_logged "${SCRIPT_DIR}/directivefinish" "$@"
        exit $?
        ;;
      archive)
        run_logged "${SCRIPT_DIR}/directivearchive" "$@"
        exit $?
        ;;
      merge)
        run_logged "${SCRIPT_DIR}/directivemerge" "$@"
        exit $?
        ;;
      cleanup)
        run_logged "${SCRIPT_DIR}/directivecleanup" "$@"
        exit $?
        ;;
      migrate)
        run_logged "${SCRIPT_DIR}/migratedirectives" "$@"
        exit $?
        ;;
      *)
        echo "Unknown directive command: ${sub:-<none>}" >&2
        usage >&2
        exit 1
        ;;
    esac
    ;;
  task)
    sub="${1:-}"
    if [[ $# -gt 0 ]]; then shift; fi
    if [[ -z "$sub" || "$sub" == "help" || "$sub" == "--help" || "$sub" == "-h" ]]; then
      category_usage "task"
      exit 0
    fi
    enforce_namespace_policy "task" "$sub"
    case "$sub" in
      start)
        run_logged "${SCRIPT_DIR}/taskstart" "$@"
        exit $?
        ;;
      finish)
        run_logged "${SCRIPT_DIR}/taskfinish" "$@"
        exit $?
        ;;
      *)
        echo "Unknown task command: ${sub:-<none>}" >&2
        usage >&2
        exit 1
        ;;
    esac
    ;;
  meta)
    sub="${1:-}"
    if [[ $# -gt 0 ]]; then shift; fi
    if [[ -z "$sub" || "$sub" == "help" || "$sub" == "--help" || "$sub" == "-h" ]]; then
      category_usage "meta"
      exit 0
    fi
    enforce_namespace_policy "meta" "$sub"
    case "$sub" in
      update)
        run_logged "${SCRIPT_DIR}/updatemeta" "$@"
        exit $?
        ;;
      architect)
        run_logged "${SCRIPT_DIR}/architect-updatemeta" "$@"
        exit $?
        ;;
      executor)
        run_logged "${SCRIPT_DIR}/executor-updatemeta" "$@"
        exit $?
        ;;
      *)
        echo "Unknown meta command: ${sub:-<none>}" >&2
        usage >&2
        exit 1
        ;;
    esac
    ;;
  validate)
    enforce_namespace_policy "validate" ""
    run_logged "${SCRIPT_DIR}/validatedirectives" "$@"
    exit $?
    ;;
  test)
    enforce_namespace_policy "test" ""
    run_logged "${SCRIPT_DIR}/testdirectives" "$@"
    exit $?
    ;;
  ns|namespace)
    enforce_namespace_policy "ns" ""
    ns_cmd "$@"
    ;;
  *)
    echo "Unknown command: $cmd" >&2
    usage >&2
    exit 1
    ;;
esac
